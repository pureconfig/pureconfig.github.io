// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Built-in Supported Types",
      "url": "/v0.17.5/docs/built-in-supported-types.html",
      "content": "Built-in Supported Types PureConfig comes with baked-in support for many types, most of them from the standard Java and Scala libraries. When using those types, users don’t have to provide anything else in order to be able to load a config. The currently supported basic types are: String, Boolean, Double (standard and percentage format ending with %), Float (also supporting percentage), Int, Long, Short, Byte, Char, URL, URI, Duration, FiniteDuration; java.lang.Enum; everything in java.time (must be configured first - see Configurable Converters); java.io.File; java.util.UUID; java.nio.file.Path; java.util.regex.Pattern and scala.util.matching.Regex; java.math.BigDecimal, java.math.BigInteger, scala.math.BigDecimal, and scala.math.BigInt; Typesafe ConfigValue, ConfigObject and ConfigList; value classes (for which readers and writers of the inner type are directly used). Additionally, PureConfig also handles the following collections and composite Scala structures: Option for optional values, i.e. values that can or cannot be in the configuration, of types on this list; collections implementing the TraversableOnce trait, where the type of the elements is on this list; Maps from String keys to any value type that is on this list; Maps from types convertible to String to any value type that is on this list (must be configured first - see Configurable Converters); shapeless.HLists of elements whose type is on this list; case classes; classes with only public val and var parameters in their constructor; sealed families of case classes (ADTs). Finally, on Scala 3 PureConfig has early support for native type class derivation. See Scala 3 Derivation for more details. The support for these types already covers most simple cases, such as the one shown in Quick Start. See Supporting New Types to see how to support types that are not on those lists and Overriding Behavior for Types to change how PureConfig reads the built-in types above."
    } ,    
    {
      "title": "Combinators",
      "url": "/v0.17.5/docs/combinators.html",
      "content": "Combinators The combinators defined in ConfigReader provide an easy way to create new ConfigReader instances by transforming existing ones. They are the simplest solution for supporting new simple types and for slightly modifying existing implementations, since the amount of boilerplate required is very small. This section contains some examples of combinators and shows how to work with them in PureConfig. The simplest combinator is map, which simply transforms the result of an existing reader: import pureconfig._ import pureconfig.generic.auto._ case class BytesConf(bytes: Vector[Byte]) // reads an array of bytes from a string implicit val byteVectorReader: ConfigReader[Vector[Byte]] = ConfigReader[String].map(_.getBytes.toVector) ConfigSource.string(\"\"\"{ bytes = \"Hello world\" }\"\"\").load[BytesConf] // res0: ConfigReader.Result[BytesConf] = Right( // BytesConf(Vector(72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100)) // ) emap allows users to validate the inputs and provide detailed failures: import pureconfig.error._ case class Port(number: Int) case class PortConf(port: Port) // reads a TCP port, validating the number range implicit val portReader = ConfigReader[Int].emap { case n if n &gt;= 0 &amp;&amp; n &lt; 65536 =&gt; Right(Port(n)) case n =&gt; Left(CannotConvert(n.toString, \"Port\", \"Invalid port number\")) } ConfigSource.string(\"{ port = 8080 }\").load[PortConf] // res1: ConfigReader.Result[PortConf] = Right(PortConf(Port(8080))) ConfigSource.string(\"{ port = -1 }\").load[PortConf] // res2: ConfigReader.Result[PortConf] = Left( // ConfigReaderFailures( // ConvertFailure( // CannotConvert(\"-1\", \"Port\", \"Invalid port number\"), // Some(ConfigOrigin(String)), // \"port\" // ), // WrappedArray() // ) // ) ensure allows users to quickly fail a reader if a condition does not hold: import pureconfig.generic.semiauto._ case class Bounds(min: Int, max: Int) implicit val boundsReader = deriveReader[Bounds] .ensure(b =&gt; b.max &gt; b.min, _ =&gt; \"Max must be bigger than Min\") ConfigSource.string(\"{ min = 1, max = 3 }\").load[Bounds] // res3: ConfigReader.Result[Bounds] = Right(Bounds(1, 3)) ConfigSource.string(\"{ min = 5, max = 3 }\").load[Bounds] // res4: ConfigReader.Result[Bounds] = Left( // ConfigReaderFailures( // ConvertFailure( // UserValidationFailed(\"Max must be bigger than Min\"), // Some(ConfigOrigin(String)), // \"\" // ), // WrappedArray() // ) // ) orElse can be used to provide alternative ways to load a config: val csvIntListReader = ConfigReader[String].map(_.split(\",\").map(_.toInt).toList) implicit val intListReader = ConfigReader[List[Int]].orElse(csvIntListReader) case class IntListConf(list: List[Int]) ConfigSource.string(\"\"\"{ list = [1,2,3] }\"\"\").load[IntListConf] // res5: ConfigReader.Result[IntListConf] = Right(IntListConf(List(1, 2, 3))) ConfigSource.string(\"\"\"{ list = \"4,5,6\" }\"\"\").load[IntListConf] // res6: ConfigReader.Result[IntListConf] = Right(IntListConf(List(4, 5, 6)))"
    } ,    
    {
      "title": "Complex Types",
      "url": "/v0.17.5/docs/complex-types.html",
      "content": "Complex Types Support for more complex types, such as Java configurations, can be achieved with many different methods, each one with pros and cons. The preferred method is shown here but for the sake of completeness this section will describe all the methods and provide hints on when one should be used instead of others. This section is organized in the following way: the first part describes an example of complex type to support, the second part provides the three methods to add support for that complex type and the final part discusses when one method should be picked instead of another one. Data type to support First of all, let’s start with the data type that we want to support. The example is composed of one interface and two implementations: trait Identifiable { def getId: String } class Class1(id: String) extends Identifiable { def getId: String = id } class Class2(id: String, value: Int) extends Identifiable { def getId: String = id def getValue: Int = value } Because PureConfig is based on shapeless and shapeless doesn’t support non-case classes and interfaces, the class above cannot be read automatically by PureConfig. Add support for Identifiable Method 1: Use a Scala copy of the configuration Because PureConfig works out-of-the-box with Scala sealed families of case classes, one simple solution to support unsupported complex types is to: define a hierarchy of Scala classes mirroring the complex type; define a conversion from this Scala configuration to the complex type. In the case above, we could do: import pureconfig._ import pureconfig.error._ import pureconfig.generic.auto._ import pureconfig.generic.FieldCoproductHint // define the \"dummy\" scala hierarchy sealed trait IdentifiableDummy { def id: String def toIdentifiable: Identifiable } final case class Class1Dummy(id: String) extends IdentifiableDummy { def toIdentifiable: Identifiable = new Class1(id) } final case class Class2Dummy(id: String, value: Int) extends IdentifiableDummy { def toIdentifiable: Identifiable = new Class2(id, value) } // change the coproduct hint to tell PureConfig that the type value specified // is the name of the class without the \"Dummy\" suffix because we want the type to // be the one of the new types, not the mirroring types implicit val identifiableCoproductHint = new FieldCoproductHint[IdentifiableDummy](\"type\") { override protected def fieldValue(name: String): String = name.take(name.length - \"Dummy\".length).toLowerCase } // we tell PureConfig that to read Identifiable, it has to read IdentifiableDummy first // and then maps it to Identifiable implicit val identifiableConfigReader1: ConfigReader[Identifiable] = ConfigReader[IdentifiableDummy].map(_.toIdentifiable) pros: it’s idiomatic and elegant. It uses a type supported by PureConfig to extract the data needed from the configuration and then maps it to the original complex type. Note that this method follows what you usually do in other libraries (e.g. Circe) to support new data types and it’s both composable and nice to read. cons: needs the configuration to be duplicated and PureConfig needs to do two steps to read it. Method 2: Implement ConfigReader[Identifiable] manually Similarly to adding support for simple types, it is possible to manually create a ConfigReader[Identifiable]: import pureconfig._ val class1Reader = ConfigReader.forProduct1(\"id\")(new Class1(_)) val class2Reader = ConfigReader.forProduct2(\"id\", \"value\")(new Class2(_, _)) def extractByType(typ: String, objCur: ConfigObjectCursor): ConfigReader.Result[Identifiable] = typ match { case \"class1\" =&gt; class1Reader.from(objCur) case \"class2\" =&gt; class2Reader.from(objCur) case t =&gt; objCur.failed(CannotConvert(objCur.objValue.toString, \"Identifiable\", s\"type has value $t instead of class1 or class2\")) } implicit val identifiableConfigReader2 = ConfigReader.fromCursor { cur =&gt; for { objCur &lt;- cur.asObjectCursor typeCur &lt;- objCur.atKey(\"type\") typeStr &lt;- typeCur.asString ident &lt;- extractByType(typeStr, objCur) } yield ident } pros: The main advantage of this method is that PureConfig delegates to it when decoding your configuration. PureConfig takes the manually defined ConfigReader[Identifiable] as a blackbox and applies it when it has to read your configuration. cons: The main advantage of this method is also its drawback, because by taking control over PureConfig in how to read sealed families of case classes, it prevents PureConfig from doing its magic. For instance, it prevents PureConfig from using the CoproductHint as strategy to read Identifiable. This is, generally speaking, not a good idea. In most cases you want PureConfig features also for your custom class. Method 3: Give a Generic representation of your configuration PureConfig is based on shapeless Generic, which is used to represent data structures in a generic form. The reason why in method 2 PureConfig was able to decode IdentifiableDummy but not Identifiable prior our code is that IdentifiableDummy has a Generic instance provided by shapeless while Identifiable doesn’t. This method consists of adding the generic representation for the configuration. Let’s start with the concrete classes Class1 and Class2. PureConfig needs to know two things in order to read them: Their generic representation; For each field in the generic representation, whether each field in the generic representation has a default value. The first item is solved by the code: import shapeless._ import shapeless.labelled._ // create the singleton idw for the field id val idw = Witness(Symbol(\"id\")) implicit val class1Generic = new LabelledGeneric[Class1] { // the generic representation of Class1 is the field id of type String override type Repr = FieldType[idw.T, String] :: HNil // mapping from/to is trivial override def to(t: Class1): Repr = field[idw.T](t.getId) :: HNil override def from(r: Repr): Class1 = new Class1(r.head) } // create the singleton valuew for the field value val valuew = Witness(Symbol(\"value\")) implicit val class2Generic = new LabelledGeneric[Class2] { // the generic representation of Class2 is the fields id of type String and value of type Int override type Repr = FieldType[idw.T, String] :: FieldType[valuew.T, Int] :: HNil // mapping from/to is trivial here too override def to(t: Class2): Repr = field[idw.T](t.getId) :: field[valuew.T](t.getValue) :: HNil override def from(r: Repr): Class2 = new Class2(r.head, r.tail.head) } The second item is trivial because neither Class1 nor Class2 have default values for fields: implicit val class1Default = new Default.AsOptions[Class1] { override type Out = Option[String] :: HNil override def apply(): Out = None :: HNil } implicit val class2Default = new Default.AsOptions[Class2] { override type Out = Option[String] :: Option[Int] :: HNil override def apply(): Out = None :: None :: HNil } After we add this, PureConfig is able to load Class1 and Class2 from configuration. The second and final part of this method is to add the generic representation of Identifiable as a sealed family of Class1 and Class2, or a coproduct of them if you want: val class1w = Witness(Symbol(\"Class1\")) val class2w = Witness(Symbol(\"Class2\")) implicit val identifiableGeneric = new LabelledGeneric[Identifiable] { override type Repr = FieldType[class1w.T, Class1] :+: FieldType[class2w.T, Class2] :+: CNil override def to(t: Identifiable): Repr = t match { case class1: Class1 =&gt; Inl(field[class1w.T](class1)) case class2: Class2 =&gt; Inr(Inl(field[class2w.T](class2))) } override def from(r: Repr): Identifiable = r match { case Inl(class1) =&gt; class1 case Inr(Inl(class2)) =&gt; class2 case _ =&gt; ??? } } pro: more efficient than method 2 because instead of using another data type, it provides the missing pieces of information to PureConfig so that PureConfig can derive the ConfigReader[Identifiable] by itself. cons: shapeless magic. If you know shapeless, this is doable, otherwise caution is recommended. Summary Method 1 is good to add support for complex types with a similar structure of what is supported by PureConfig, e.g. products and coproducts; Method 2 is good to add support for simple types or types that don’t need PureConfig’s way to decode products (case classes) or coproducts (sealed families of classes); Method 3 is good when method 2 is too slow or when you need to add only part of the information to let PureConfig work, e.g. if you had the generic representation of Class1 and you just have to add the default instance for the arguments. The preferred method is method 1 because it’s the easiest to use and the more idiomatic. In libraries like PureConfig, the best way to add a new data type is often to take something supported by the library and “map it” to the new data type."
    } ,    
    {
      "title": "Config Cursors",
      "url": "/v0.17.5/docs/config-cursors.html",
      "content": "Config Cursors When a ConfigReader needs to be created from scratch, users need to implement a from method with the following signature: def from(cur: ConfigCursor): ConfigReader.Result[A] The ConfigCursor class is a wrapper for the raw ConfigValue provided by Typesafe Config. It provides an idiomatic, typesafe API for the most common operations needed while reading a config. In particular, it provides cast operations and key accesses that integrate neatly with the PureConfig errors API. When using cursors properly, most errors are automatically handled and filled with rich information about the location of the failure. We’ll show how to implement our own ConfigReader for the following class: class Person(firstName: String, lastNames: Array[String]) { override def toString = s\"Person($firstName ${lastNames.mkString(\" \")})\" } case class Conf(person: Person) We intend our config to look like this: import com.typesafe.config.ConfigFactory val conf = ConfigFactory.parseString(\"person.name: John Doe\") For the purposes of this example, we’ll assume the provided name will always have at least two words. An implementation of the ConfigReader using the cursor API is shown below: import pureconfig._ import pureconfig.generic.auto._ def firstNameOf(name: String): String = name.takeWhile(_ != ' ') def lastNamesOf(name: String): Array[String] = name.dropWhile(_ != ' ').drop(1).split(\" \") implicit val personReader = ConfigReader.fromCursor[Person] { cur =&gt; for { objCur &lt;- cur.asObjectCursor // 1 nameCur &lt;- objCur.atKey(\"name\") // 2 name &lt;- nameCur.asString // 3 } yield new Person(firstNameOf(name), lastNamesOf(name)) } The factory method ConfigReader.fromCursor allows us to create a ConfigReader without much boilerplate by providing the required ConfigCursor =&gt; ConfigReader.Result[A] function. Since most methods in the cursor API return Either values with failures at their left side, for comprehensions are a natural fit. Let’s analyze the lines marked above: asObjectCursor casts a cursor to a special ConfigObjectCursor, which contains methods exclusive to config objects. If the provided config value is not an object, the method returns a Left and the execution stops here; atKey is defined only on object cursors and accesses a given key on the underlying object. Once more, trying to access a non-existing key results in an error, stopping the for comprehension; having a cursor for the name key we want, asString tries to cast the config value pointed to by the cursor to a string. You can use the fluent cursor API, an alternative interface focused on easy navigation over error handling, to achieve the same effect: implicit val personReader = ConfigReader.fromCursor[Person] { cur =&gt; cur.fluent.at(\"name\").asString.map { name =&gt; new Person(firstNameOf(name), lastNamesOf(name)) } } Either way, a well-formed config will now work correctly: ConfigSource.fromConfig(conf).load[Conf] // res1: ConfigReader.Result[Conf] = Right(Conf(Person(John Doe))) While malformed configs will fail to load with appropriate errors: ConfigSource.string(\"person = 45\").load[Conf] // res2: ConfigReader.Result[Conf] = Left( // ConfigReaderFailures( // ConvertFailure( // WrongType(NUMBER, Set(OBJECT)), // Some(ConfigOrigin(String)), // \"person\" // ), // WrappedArray() // ) // ) ConfigSource.string(\"person.eman = John Doe\").load[Conf] // res3: ConfigReader.Result[Conf] = Left( // ConfigReaderFailures( // ConvertFailure( // KeyNotFound(\"name\", Set()), // Some(ConfigOrigin(String)), // \"person\" // ), // WrappedArray() // ) // ) ConfigSource.string(\"person.name = [1, 2]\").load[Conf] // res4: ConfigReader.Result[Conf] = Left( // ConfigReaderFailures( // ConvertFailure( // WrongType(LIST, Set(STRING)), // Some(ConfigOrigin(String)), // \"person.name\" // ), // WrappedArray() // ) // ) By using the appropriate ConfigCursor methods, all error handling was taken care of by PureConfig. That makes PureConfig easy to use even when users have to deal with the low-level details of the conversions."
    } ,    
    {
      "title": "Config Writers",
      "url": "/v0.17.5/docs/config-writers.html",
      "content": "Config Writers The main use case for PureConfig, as described in the homepage, is to load configuration files to Scala classes in a typesafe and boilerplate-free way. However, there are situations where users may have the need to do the inverse operation: to write a config file from a Scala data structure. An example would be to save a config after it is changed in-app. Just as PureConfig provides a ConfigReader interface for reading configurations, it also provides a ConfigWriter for writing configs. All types mentioned at Built-in Supported Types are supported both in reading and in writing operations: import pureconfig._ import pureconfig.generic.auto._ sealed trait MyAdt case class AdtA(a: String) extends MyAdt case class AdtB(b: Int) extends MyAdt final case class Port(value: Int) extends AnyVal case class MyClass( boolean: Boolean, port: Port, adt: MyAdt, list: List[Double], map: Map[String, String], option: Option[String]) val confObj = MyClass(true, Port(8080), AdtB(1), List(1.0, 0.2), Map(\"key\" -&gt; \"value\"), None) ConfigWriter[MyClass].to(confObj) // res1: com.typesafe.config.ConfigValue = SimpleConfigObject({\"adt\":{\"b\":1,\"type\":\"adt-b\"},\"boolean\":true,\"list\":[1.0,0.2],\"map\":{\"key\":\"value\"},\"port\":8080}) The mechanisms with which PureConfig finds out how to write a type to a config are the same as ones used with ConfigReader. Therefore, you can use most tutorials and tips at Supporting New Types and Overriding Behavior for Types for creating ConfigWriter instances, too. ConfigWriter also has useful combinators and factory methods to simplify new implementations: class MyInt(value: Int) { def getValue: Int = value override def toString: String = s\"MyInt($value)\" } implicit val myIntWriter = ConfigWriter[Int].contramap[MyInt](_.getValue) ConfigWriter[MyInt].to(new MyInt(1)) // res2: com.typesafe.config.ConfigValue = ConfigInt(1) Finally, if you need both the reading and the writing part for a custom type, you can implement a ConfigConvert: implicit val myIntConvert = ConfigConvert[Int].xmap[MyInt](new MyInt(_), _.getValue) val conf = ConfigWriter[MyInt].to(new MyInt(1)) // conf: com.typesafe.config.ConfigValue = ConfigInt(1) ConfigReader[MyInt].from(conf) // res3: ConfigReader.Result[MyInt] = Right(MyInt(1)) A ConfigConvert implements both the ConfigReader and ConfigWriter interfaces and can be used everywhere one of them is needed."
    } ,    
    {
      "title": "Configurable Converters",
      "url": "/v0.17.5/docs/configurable-converters.html",
      "content": "Configurable Converters For some types, PureConfig cannot automatically derive a reader because there are multiple ways to convert a configuration value to them. For instance, for LocalDate PureConfig cannot derive a reader because there are multiple DateTimeFormatters that can be used to convert a string into a LocalDate. Examples of different formats are yyyy-mm-dd, e.g. \"2016-01-01\", and yyyymmdd, e.g. \"20160101\". Another example is reading maps with non-string keys: unless a way to convert the keys to and from strings is provided, PureConfig won’t be able to derive a reader. For those types, PureConfig provides a way to create readers from the necessary parameters. These methods can be found under the package pureconfig.configurable. Once the output of a pureconfig.configurable method for a certain type is in scope, PureConfig can start using that configured reader. Define a case class to hold your configuration, and create a configurable reader: import java.time.LocalDate import java.time.format.DateTimeFormatter import pureconfig._ import pureconfig.configurable._ import pureconfig.ConvertHelpers._ import pureconfig.generic.auto._ case class Conf(date: LocalDate, intMap: Map[Int, Int]) implicit val localDateConvert = localDateConfigConvert(DateTimeFormatter.ISO_DATE) implicit val intMapReader = genericMapReader[Int, Int](catchReadError(_.toInt)) Then load the configuration: ConfigSource.string(\"{ date: 2011-12-03, int-map: { 2: 4, 4: 16 } }\").load[Conf] // res0: ConfigReader.Result[Conf] = Right( // Conf(2011-12-03, Map(4 -&gt; 16, 2 -&gt; 4)) // )"
    } ,    
    {
      "title": "Error Handling",
      "url": "/v0.17.5/docs/error-handling.html",
      "content": "Error Handling PureConfig features a rich error model used on reading operations. Most PureConfig methods that read Scala types from configurations return a ConfigReader.Result[A] - an alias for Either[ConfigReaderFailures, A], with A being the type of a successful result and ConfigReaderFailures being a non-empty list of errors that caused the reading operation to fail. From the various types of ConfigReaderFailure, one of them is of particular interest: a ConvertFailure is an error occurred during the conversion process itself. It features a reason (FailureReason), an optional location in the config files where the conversion error occurred and a path in the config. There are several possible FailureReasons, the most common being: A general, uncategorized reason (CannotConvert); A required key was not found (KeyNotFound); A config value has a wrong type (WrongType). For example, given a config like this: import pureconfig._ import pureconfig.generic.auto._ case class Name(firstName: String, lastName: String) case class Person(name: Name, age: Int) case class PersonConf(person: Person) Trying to load it with a string instead of an object at name results in a ConvertFailure because of a WrongType: val res = ConfigSource.string(\"{ person: { name: John Doe, age: 35 } }\").load[PersonConf] // res: ConfigReader.Result[PersonConf] = Left( // ConfigReaderFailures( // ConvertFailure( // WrongType(STRING, Set(OBJECT)), // Some(ConfigOrigin(String)), // \"person.name\" // ), // WrappedArray() // ) // ) All error-related classes are present in the pureconfig.error package. Validations in custom readers When implementing custom readers, the cursor API already deals with the most common reasons for a reader to fail. However, it also provides a failed method for users to do validations on their side, too: import com.typesafe.config.ConfigValueType._ import scala.util.{Try, Success, Failure} import pureconfig.error._ case class PositiveInt(value: Int) { require(value &gt;= 0) } implicit val positiveIntReader = ConfigReader.fromCursor[PositiveInt] { cur =&gt; cur.asString.flatMap { str =&gt; Try(str.toInt) match { case Success(n) if n &gt;= 0 =&gt; Right(PositiveInt(n)) case Success(n) =&gt; cur.failed(CannotConvert(str, \"PositiveInt\", s\"$n is not positive\")) case Failure(_) =&gt; cur.failed(WrongType(STRING, Set(NUMBER))) } } } case class Conf(n: PositiveInt) ConfigSource.string(\"{ n: 23 }\").load[Conf] // res0: ConfigReader.Result[Conf] = Right(Conf(PositiveInt(23))) ConfigSource.string(\"{ n: -23 }\").load[Conf] // res1: ConfigReader.Result[Conf] = Left( // ConfigReaderFailures( // ConvertFailure( // CannotConvert(\"-23\", \"PositiveInt\", \"-23 is not positive\"), // Some(ConfigOrigin(String)), // \"n\" // ), // WrappedArray() // ) // ) ConfigSource.string(\"{ n: abc }\").load[Conf] // res2: ConfigReader.Result[Conf] = Left( // ConfigReaderFailures( // ConvertFailure( // WrongType(STRING, Set(NUMBER)), // Some(ConfigOrigin(String)), // \"n\" // ), // WrappedArray() // ) // ) Custom failure reasons Users are not restricted to the failure reasons provided by PureConfig. If we wanted to use a domain-specific failure reason for our PositiveInt, for example, we could create it like this: case class NonPositiveInt(value: Int) extends FailureReason { def description = s\"$value is not positive\" } implicit val positiveIntReader = ConfigReader.fromCursor[PositiveInt] { cur =&gt; cur.asString.flatMap { str =&gt; Try(str.toInt) match { case Success(n) if n &gt;= 0 =&gt; Right(PositiveInt(n)) case Success(n) =&gt; cur.failed(NonPositiveInt(n)) case Failure(_) =&gt; cur.failed(WrongType(STRING, Set(NUMBER))) } } } ConfigSource.string(\"{ n: -23 }\").load[Conf] // res3: ConfigReader.Result[Conf] = Left( // ConfigReaderFailures( // ConvertFailure(NonPositiveInt(-23), Some(ConfigOrigin(String)), \"n\"), // WrappedArray() // ) // ) Throwing an exception instead of returning Either In some usage patterns, there isn’t a need to deal with errors as values. For example, a good practice to handle configs in an application is to load the whole config with PureConfig at initialization time, causing the application to fail fast in case of a malformed config. For those cases, the loadOrThrow method can be used instead of load: ConfigSource.string(\"{ n: 23 }\").loadOrThrow[Conf] // res4: Conf = Conf(PositiveInt(23)) ConfigSource.string(\"{ n: -23 }\").loadOrThrow[Conf] // pureconfig.error.ConfigReaderException: Cannot convert configuration to a repl.MdocSession$MdocApp$Conf. Failures are: // at 'n': // - (String: 1) -23 is not positive // // at pureconfig.ConfigSource.loadOrThrow(ConfigSource.scala:81) // at pureconfig.ConfigSource.loadOrThrow$(ConfigSource.scala:78) // at pureconfig.ConfigObjectSource.loadOrThrow(ConfigSource.scala:92) // at repl.MdocSession$MdocApp$$anonfun$11.apply(error-handling.md:108) // at repl.MdocSession$MdocApp$$anonfun$11.apply(error-handling.md:108) The message of the thrown exception contains human-readable information of all the errors found by PureConfig, with the errors grouped and organized by path."
    } ,    
    {
      "title": "FAQ",
      "url": "/v0.17.5/docs/faq.html",
      "content": "FAQ Here are some of the questions about PureConfig frequently asked on issues and other channels: How can I use PureConfig with Spark 2.1.0 (problematic shapeless dependency)? How can I avoid displaying sensitive parts of my configuration, such as passwords, when I print the result of PureConfig? How do I debug “implicit not found” errors? How can I use PureConfig with Spark 2.1.0 (problematic shapeless dependency)? Apache Spark (specifically version 2.1.0) has a transitive dependency on shapeless 2.0.0. This version is too old to be used by PureConfig, making your Spark project fail when using spark-submit. The solution is to shade, i.e. rename, the version of shapeless used by PureConfig. SBT If you are using the sbt-assembly plugin to create your JARs you can shade shapeless by adding to your assembly.sbt file the following setting: assembly / assemblyShadeRules := Seq(ShadeRule.rename(\"shapeless.**\" -&gt; \"new_shapeless.@1\").inAll) Maven The maven-shade-plugin can shade shapeless by adding to your pom.xml file the following block: &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt; &lt;relocations&gt; &lt;relocation&gt; &lt;pattern&gt;shapeless&lt;/pattern&gt; &lt;shadedPattern&gt;shapelesspureconfig&lt;/shadedPattern&gt; &lt;/relocation&gt; &lt;/relocations&gt; &lt;/configuration&gt; &lt;/plugin&gt; How can I avoid displaying sensitive parts of my configuration, such as passwords, when I print the result of PureConfig? Configuration commonly includes sensitive information, such as passwords or keys. Generally these values should not appear in logging. Unfortunately this means that Scala’s typically helpful behavior of generating transparent toString methods gets in the way. When a configuration is loaded into a case class, then the default toString generated by Scala will display sensitive information. This behavior is standard Scala and has nothing to do with PureConfig per se. A solution we’ve seen address this concern is to wrap the sensitive field in an AnyVal new type which simply redefines toString. Please see the example below: import pureconfig._ import pureconfig.generic.auto._ case class Sensitive(value: String) extends AnyVal { override def toString: String = \"MASKED\" } case class SuperSecretConfig( username: String, password: Sensitive, apiKey: Sensitive) Then when we print out the SuperSecretConfig after loading it via PureConfig, the sensitive values are masked: val secret = ConfigSource.string(\"\"\"{ username: john.smith password: password123 api-key: 8ef72f48-2143-48af-9573-3b519bbcb777 }\"\"\").loadOrThrow[SuperSecretConfig] // secret: SuperSecretConfig = SuperSecretConfig( // \"john.smith\", // Sensitive(\"password123\"), // Sensitive(\"8ef72f48-2143-48af-9573-3b519bbcb777\") // ) println(secret) // SuperSecretConfig(john.smith,MASKED,MASKED) But, of course, the values we need are still there: secret.password.value // res2: String = \"password123\" secret.apiKey.value // res3: String = \"8ef72f48-2143-48af-9573-3b519bbcb777\" How do I debug “implicit not found” errors? When we want to load a config with a large structure and Scala refuses to compile a reader for it, it can be difficult to understand the reason of the failure. Consider the following example: import pureconfig._ import pureconfig.generic.auto._ // not a case class class Custom(x: Int, s: String) { def asString = s\"x = $x, s = $s\" } // not a case class class Custom2(x: Int, s: String) { def asString = s\"x: $x, s: $s\" } sealed trait Conf case class ConfA(a: Boolean, b: Option[Boolean]) extends Conf sealed trait ConfB extends Conf case class ConfB1(a: Int) extends ConfB case class ConfB2(a: String) extends ConfB case class ConfC(a: Option[Custom], b: Custom2) extends Conf When we try to load a Conf from a config, we’ll simply get this error message: ConfigSource.default.load[Conf] // error: could not find implicit value for parameter reader: pureconfig.ConfigReader[MdocApp1.this.Conf] // ConfigSource.default.load[Conf] // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ In PureConfig, the derivation of config readers and writers is done by chaining implicits - the converters of larger structures (like Conf) depend on the implicit converters of smaller ones (like Boolean or Custom). However, the Scala compiler for Scala 2.x is not helpful by default in case one of those upstream dependencies is missing, limiting itself to showing the message above. To more efficiently debug these “implicit not found” errors, we recommend using splain. splain was integrated into the compiler in Scala 2.13.6 and can be enabled with the -Vimplicits scalac flag. For Scala 2.13 versions prior to 2.13.6 or Scala 2.12 versions, please refer to the project’s documentation for instructions on how to include the compiler plugin. When code using PureConfig derived converters is compiled using the compiler plugin recommended above, you will get a more thorough error message. In this particular case, the message will be quite large because there are some alternative implicit paths to try and the path until we arrive at an implicit not found outside PureConfig’s derivation code is big: ConfigSource.default.load[Conf] // [error] !I reader: ConfigReader[Conf] // [error] shapeless.lazily.apply invalid because // [error] !I lv: DerivedConfigReader[Conf] // [error] ――DerivedConfigReader.productReader invalid because // [error] !I gen: LabelledGeneric.Aux[Conf, Repr] // [error] ――――LabelledGeneric.materializeProduct invalid because // [error] !I gen: Generic.Aux[Conf, V] // ... // [error] ConfigSource.default.load[Conf] // [error] ^ The error message above shows that the compiler tried various alternatives to create a ConfigReader for Conf but all of them failed due to some missing implicits deeper down in the path. A way to find which implicits we failed to provide as downstream users is to look for missing ConfigReader instances deeper in the chain. One of them is shown when attempting to use ConfigReader.optionReader: // [error] !I reader: ConfigReader[Conf] // [error] shapeless.lazily.apply invalid because // [error] !I lv: DerivedConfigReader[Conf] // [error] ――DerivedConfigReader.productReader invalid because // [error] !I gen: LabelledGeneric.Aux[Conf, Repr] // [error] ――――LabelledGeneric.materializeProduct invalid because // [error] !I gen: Generic.Aux[Conf, V] // [error] // ... // [error] ――――――――――――――――――――――――――DerivedConfigReader.productReader invalid because // [error] !I cc: MapShapedReader[ConfC, Repr, DefaultRepr] // [error] ――――――――――――――――――――――――――――MapShapedReader.labelledHConsReader invalid because // ... // [error] ――――――――――――――――――――――――――――――――――ConfigReader.optionReader invalid because // [error] !I conv: ConfigReader[Custom] // ... // [error] ConfigSource.default.load[Conf] // [error] ^ This tells us that there’s a missing ConfigReader in scope for type Custom. Since Custom isn’t a case class nor a sealed trait, we’re unable to derive a ConfigReader for it using PureConfig’s generic derivation. Making Custom a case class or explicitly providing a ConfigReader instance for it helps us get rid of this error. Once that’s fixed, we’re still left with another error. Similarly, we can look for missing ConfigReader instances deeper in the chain. We’re able to find one missing for Custom2: // [error] !I reader: ConfigReader[Conf] // [error] shapeless.lazily.apply invalid because // [error] !I lv: DerivedConfigReader[Conf] // [error] ――DerivedConfigReader.productReader invalid because // [error] !I gen: LabelledGeneric.Aux[Conf, Repr] // [error] ――――LabelledGeneric.materializeProduct invalid because // [error] !I gen: Generic.Aux[Conf, V] // ... // [error] ――――――――――――――――――――――――――DerivedConfigReader.productReader invalid because // [error] !I cc: MapShapedReader[ConfC, Repr, DefaultRepr] // [error] ――――――――――――――――――――――――――――MapShapedReader.labelledHConsReader invalid because // [error] !I tConfigReader: MapShapedReader[ConfC, ('b -&gt;&gt; Custom2) :: HNil, Option[Custom2] :: HNil] // [error] ――――――――――――――――――――――――――――――MapShapedReader.labelledHConsReader invalid because // [error] !I hConfigReader: ConfigReader[Custom2] // ... // [error] ConfigSource.default.load[Conf] // [error] ^ Custom2 isn’t also a case class nor a sealed trait, so either making it a case class or explicitly providing a ConfigReader instance would fix our error."
    } ,      
    {
      "title": "Quick Start",
      "url": "/v0.17.5/docs/",
      "content": "Quick Start To use PureConfig in an existing SBT project with Scala 2.12 or a later version, add the following dependency to your build.sbt: libraryDependencies += \"com.github.pureconfig\" %% \"pureconfig\" % \"0.17.5\" For a full example of build.sbt you can have a look at this build.sbt. Earlier versions of Scala had bugs which can cause subtle compile-time problems in PureConfig. As a result we recommend only using the latest Scala versions within the minor series. In your code, import pureconfig.generic.auto and define data types and a case class to hold the configuration: import pureconfig._ import pureconfig.generic.auto._ case class Port(number: Int) extends AnyVal sealed trait AuthMethod case class Login(username: String, password: String) extends AuthMethod case class Token(token: String) extends AuthMethod case class PrivateKey(pkFile: java.io.File) extends AuthMethod case class ServiceConf( host: String, port: Port, useHttps: Boolean, authMethods: List[AuthMethod] ) Second, create an application.conf file and add it as a resource of your application (with SBT, they are usually placed in src/main/resources): // src/main/resources/application.conf host = \"example.com\" port = 8080 use-https = true auth-methods = [ { type = \"private-key\", pk-file = \"/home/user/myauthkey\" }, { type = \"login\", username = \"pureconfig\", password = \"12345678\" } ] Note the usage of different naming conventions for config keys and class fields, which you can customize later. Finally, load the configuration: ConfigSource.default.load[ServiceConf] // res4: ConfigReader.Result[ServiceConf] = Right( // ServiceConf( // \"example.com\", // Port(8080), // true, // List(PrivateKey(/home/user/myauthkey), Login(\"pureconfig\", \"12345678\")) // ) // ) ConfigReader.Result[ServiceConf] is just an alias for Either[ConfigReaderFailures, ServiceConf], so you can handle it just like you would handle an Either value. ConfigSource.default defers to Typesafe Config’s ConfigFactory to select where to load the config files from. Typesafe Config has well-documented rules for configuration loading which we’ll not repeat. Please see Typesafe Config’s documentation for a full telling of the subtleties and see Loading a Config for alternative sources for configuration files. Because PureConfig uses Typesafe Config to load configurations, it supports reading files in HOCON, JSON, and Java .properties formats. HOCON is a delightful superset of both JSON and .properties that is highly recommended. As an added bonus it supports advanced features like variable substitution and file sourcing."
    } ,    
    {
      "title": "Library Integrations",
      "url": "/v0.17.5/docs/library-integrations.html",
      "content": "Library Integrations Internal Modules The core of PureConfig eschews unnecessary dependencies. Separate modules exist to support types which are not part of the standard Scala and Java libraries: pureconfig-akka provides converters for Akka data types; pureconfig-akka-http provides converters for Akka-Http models; pureconfig-cats provides converters for Cats data structures and Cats typeclass instances; pureconfig-cats-effect uses cats-effect to load and save configurations in a side-effect free manner; pureconfig-circe provides converters for Circe’s Json AST; pureconfig-cron4s provides converters for Cron4s types; pureconfig-enum provides converters for enums generated by julienrf’s enum library; pureconfig-enumeratum provides converters for enums generated by Enumeratum; pureconfig-fs2 provides support for reading configuration from and writing to fs2 streams; pureconfig-hadoop provides converters for Hadoop types; pureconfig-http4s provides converters for Http4s types; pureconfig-ip4s provides converters for Ip4s types; pureconfig-javax provides converters for classes in javax packages; pureconfig-joda provides configurable converters for Joda-Time types; pureconfig-magnolia provides an alternative way to derive readers and writers for case classes and sealed traits using Magnolia; pureconfig-scala-xml provides support for XML via scala-xml; pureconfig-scalaz provides converters for Scalaz data structures and Scalaz typeclass instances; pureconfig-squants provides converters for Squants’s beautiful types representing units of measure; pureconfig-sttp provides converters for sttp types; pureconfig-yaml provides support for reading YAML files as configurations. pureconfig-zio-config provides converters given instances of ZIO Config ConfigDescriptor. External Integrations A non-comprehensive list of other libraries which have integrated with PureConfig to provide a richer experience include: refined-pureconfig allows PureConfig to play nicely with refined’s type refinements; coulomb-pureconfig enables PureConfig configurations to include coulomb Quantity values."
    } ,    
    {
      "title": "Loading a Config",
      "url": "/v0.17.5/docs/loading-a-config.html",
      "content": "Loading a Config In Quick Start we used ConfigSource.default.load[MyClass] to read a config from an application.conf resource and convert it to a case class. ConfigSource.default is an instance of ConfigSource - a trait representing sources from which we can load configuration data. This ConfigSource in particular reads and builds a config according to Typesafe Config’s standard behavior, which means it can be used as a replacement for ConfigFactory.load in codebases already using Typesafe Config. The ConfigSource companion object defines many other ready-to-use sources, like: ConfigSource.file - reads a config from a file in a file system; ConfigSource.resources - reads a config from resources in your classpath or packaged application; ConfigSource.url - reads a config from a URL; ConfigSource.string - reads a literal config from a string. After you have a config source you can load your config using several methods: import pureconfig._ import pureconfig.generic.auto._ case class Conf(name: String, age: Int) val source = ConfigSource.string(\"{ name = John, age = 33 }\") // reads a config and loads it into a `Either[ConfigReaderFailures, Conf]` source.load[Conf] // res0: ConfigReader.Result[Conf] = Right(Conf(\"John\", 33)) // reads a config and loads it into a `Conf` (throwing if not possible) source.loadOrThrow[Conf] // res1: Conf = Conf(\"John\", 33) // reads a raw config from `source` source.config() // res2: ConfigReader.Result[com.typesafe.config.Config] = Right( // Config(SimpleConfigObject({\"age\":33,\"name\":\"John\"})) // ) // reads a config as a `ConfigCursor` (see \"Config Cursors\" section) source.cursor() // res3: ConfigReader.Result[ConfigCursor] = Right( // ConfigObjectCursor(SimpleConfigObject({\"age\":33,\"name\":\"John\"}), List()) // ) As you use PureConfig you’ll find yourself using mostly load and loadOrThrow. The last two examples would be used only in more complex or specific scenarios. Combining Sources A common pattern when loading configs is to read and merge from multiple config sources - maybe you have app-specific and user-specific configs you want to merge in some order, or maybe you want to fall back to some default configuration if a file doesn’t exist or cannot be read. Most ConfigSource instances are also instances of ConfigObjectSource - a more specific type of source that is guaranteed to produce a config object (instead of say, an array or a scalar value). ConfigObjectSource instances are equipped with an .withFallback method you can use to merge configs: val appSource = ConfigSource.string(\"{ age = 33 }\") val defaultsSource = ConfigSource.string(\"{ name = Admin, age = -1 }\") appSource.withFallback(defaultsSource).load[Conf] // res4: ConfigReader.Result[Conf] = Right(Conf(\"Admin\", 33)) Sometimes you want some of the sources in your chain to be optional. You can call .optional on any ConfigObjectSource to make it produce an empty config if the underlying source cannot be read: val otherAppSource = ConfigSource.file(\"non-existing-file.conf\") otherAppSource.withFallback(defaultsSource).load[Conf] // res5: ConfigReader.Result[Conf] = Left( // ConfigReaderFailures( // CannotReadFile( // non-existing-file.conf, // Some( // java.io.FileNotFoundException: non-existing-file.conf (No such file or directory) // ) // ), // WrappedArray() // ) // ) otherAppSource.optional.withFallback(defaultsSource).load[Conf] // res6: ConfigReader.Result[Conf] = Right(Conf(\"Admin\", -1)) You also have the option to use an alternative source in case your primary source can’t be read by using .recoverWith: otherAppSource.recoverWith { case _ =&gt; defaultsSource }.load[Conf] // res7: ConfigReader.Result[Conf] = Right(Conf(\"Admin\", -1)) Loading a Config in a Path You may want your application config to be loaded from a specific path in the config files, e.g. if you want to have configs for multiple apps in the same sources. ConfigSource instances have an .at method you can use to specify where you want the config to be read from: val multiAppSource = ConfigSource.string(\"\"\" app-a: { timeout: 5s retries: 3 } app-b: { host: example.com port: 8087 } \"\"\") case class MyAppConf(host: String, port: Int) multiAppSource.at(\"app-b\").load[MyAppConf] // res8: ConfigReader.Result[MyAppConf] = Right(MyAppConf(\"example.com\", 8087)) Customizing Typesafe Config’s Behavior If you want only parts of Typesafe Config’s standard behavior or want to customize something in their pipeline, PureConfig provides ConfigSources like defaultReference, defaultApplication, defaultOverrides and systemProperties, which you can use to mix and match to fit your needs. Take a look at their Scaladoc for more information about each of them."
    } ,    
    {
      "title": "Non-Automatic Derivation",
      "url": "/v0.17.5/docs/non-automatic-derivation.html",
      "content": "Non-Automatic Derivation All the examples in the documentation rely on automatic derivation of readers and writers for case classes and sealed traits. That is the recommended way of using PureConfig, in line with its core goal of providing a boilerplate-free but still type-safe way of handling config files. However, some users may prefer to declare explicitly their intention to derive readers for a type, some advanced users may have their own ways of deriving readers and some may not want to use derivation at all. PureConfig actually provides three ways of setting up reader derivation, which are presented in the next sections. Automatic First, let’s define an example case class and a config for us to load: import com.typesafe.config.ConfigFactory import pureconfig._ case class Person(name: String, surname: String) val conf = ConfigFactory.parseString(\"{ name: John, surname: Doe }\") Automatic reader derivation is used throughout all the documentation pages. It is activated simply by importing pureconfig.generic.auto._ everywhere readers are needed (for example, where ConfigSource#load is used): import pureconfig.generic.auto._ This import provides ConfigReader instances for all supported classes out-of-the-box: ConfigSource.fromConfig(conf).load[Person] // res0: ConfigReader.Result[Person] = Right(Person(\"John\", \"Doe\")) Internally, derivation is made through the use of shapeless, a generic programming Scala library. Custom readers can still be placed in the companion object of the respective classes; PureConfig will make sure that they are used instead of the automatically-derived ones. Semi-Automatic With semi-automatic derivation, readers can still be derived using all the machinery presented on these documentation pages, but the reader instances are not provided as implicits. Instead, PureConfig provides two one-liner methods to create derived instances, which you must put somewhere on the implicit scope. Semi-automatic derivation is enabled by importing pureconfig.generic.semiauto._. We can now explicitly define the reader for Person by calling deriveReader: import pureconfig.generic.semiauto._ implicit val personReader = deriveReader[Person] We are now ready to read Person configs: ConfigSource.fromConfig(conf).load[Person] // res2: ConfigReader.Result[Person] = Right(Person(\"John\", \"Doe\")) Semi-Automatic for Sealed Families To support a sealed family with semi-automatic derivation, you’ll need to provide a derivation for every concrete member of the family and the base of the family. sealed trait Occupation extends Product with Serializable object Occupation { case class Employed(job: String) extends Occupation object Employed { implicit val employedReader = deriveReader[Employed] } case object Unemployed extends Occupation { implicit val unemployedReader = deriveReader[Unemployed.type] } case object Student extends Occupation { implicit val studentReader = deriveReader[Student.type] } implicit val occupationReader = deriveReader[Occupation] } case class WorkingPerson(name: String, surname: String, occupation: Occupation) object WorkingPerson { implicit val workingPersonReader = deriveReader[WorkingPerson] } ConfigSource.string(\"{ name: Isaac, surname: Newton, occupation.type: student }\").load[WorkingPerson] // res3: ConfigReader.Result[WorkingPerson] = Right( // WorkingPerson(\"Isaac\", \"Newton\", Student) // ) ConfigSource.string(\"\"\"{ name: David, surname: Shingy, occupation: { type: employed, job: Digital Prophet } }\"\"\").load[WorkingPerson] // res4: ConfigReader.Result[WorkingPerson] = Right( // WorkingPerson(\"David\", \"Shingy\", Employed(\"Digital Prophet\")) // ) Manual When case class and sealed trait derivation is not needed or wanted, we can simply not import anything and define our reader using any of ways explained in Supporting New Types. The forProductN helper methods are convenient for creating readers and writers for case class-like types without generic derivation: import pureconfig._ implicit val personReader = ConfigReader.forProduct2(\"name\", \"surname\")(Person(_, _)) ConfigSource.fromConfig(conf).load[Person] // res6: ConfigReader.Result[Person] = Right(Person(\"John\", \"Doe\")) If you don’t need reader or writer derivation anywhere in your project, you can replace the pureconfig Maven dependency with pureconfig-core. pureconfig-core contains only the core classes needed by PureConfig, as well as readers and writers for primitive and collection types. It has the advantage of not depending on shapeless, which can be useful to prevent version conflicts."
    } ,    
    {
      "title": "Case Classes",
      "url": "/v0.17.5/docs/overriding-behavior-for-case-classes.html",
      "content": "Case Classes PureConfig has to assume some conventions and behaviors when deriving ConfigReader instances for case classes: How do keys in config objects map to field names of the case class? Are unknown keys allowed in the config object? Should default values in case class fields be applied when its respective config key is missing? By default, PureConfig: expects config keys to be written in kebab case (such as my-field) and the associated field names are written in camel case (such as myField); allows unknown keys; uses the default values when a key is missing. All of these assumptions can be overridden by putting an implicit ProductHint in scope - an object that “hints” PureConfig on how to best derive converters for products. Field mappings In case the naming convention you use in your configuration files differs from the default one, PureConfig allows you to define the mappings to use. A mapping between different naming conventions is done using a ConfigFieldMapping object, with which one can construct a ProductHint. The ConfigFieldMapping trait has a single apply method that maps field names in Scala objects to field names in the source configuration file. For instance, here’s a contrived example where the configuration file has all keys in upper case and we’re loading it into a type whose fields are all in lower case. First, define a ProductHint instance in implicit scope: import pureconfig._ import pureconfig.generic.auto._ import pureconfig.generic.ProductHint case class SampleConf(foo: Int, bar: String) implicit val productHint = ProductHint[SampleConf](new ConfigFieldMapping { def apply(fieldName: String) = fieldName.toUpperCase }) Then load a config: ConfigSource.string(\"{ FOO: 2, BAR: two }\").load[SampleConf] // res0: ConfigReader.Result[SampleConf] = Right(SampleConf(2, \"two\")) PureConfig provides a way to create a ConfigFieldMapping by defining the naming conventions of the fields in the Scala object and in the configuration file. Some of the most used naming conventions are supported directly in the library: CamelCase (examples: camelCase, useMorePureconfig); SnakeCase (examples: snake_case, use_more_pureconfig); ScreamingSnakeCase (examples: SCREAMING_SNAKE_CASE, USE_MORE_PURECONFIG); KebabCase: (examples: kebab-case, use-more-pureconfig); PascalCase: (examples: PascalCase, UseMorePureconfig). You can use the apply method of ConfigFieldMapping that accepts the two naming conventions (for the fields in the Scala object and for the fields in the configuration file, respectively). A common use case is to have both your field names and your configuration files in camelCase. In order to support it, you can make sure the following implicit is in scope before loading or writing configuration files: implicit def hint[A] = ProductHint[A](ConfigFieldMapping(CamelCase, CamelCase)) Default field values If a case class has a default argument and the underlying configuration is missing a value for that field, then by default PureConfig will happily create an instance of the class, loading the other values from the configuration. For example, with this setup: import pureconfig._ import pureconfig.generic.auto._ import pureconfig.generic.ProductHint import scala.concurrent.duration._ import scala.language.postfixOps case class Holiday(where: String = \"last resort\", howLong: Duration = 7 days) We can load configurations using default values: // Defaulting `where` ConfigSource.string(\"{ how-long: 21 days }\").load[Holiday] // res2: ConfigReader.Result[Holiday] = Right(Holiday(\"last resort\", 21 days)) // Defaulting `howLong` ConfigSource.string(\"{ where: Zürich }\").load[Holiday] // res3: ConfigReader.Result[Holiday] = Right(Holiday(\"Zürich\", 7 days)) // Defaulting both arguments ConfigSource.string(\"{}\").load[Holiday] // res4: ConfigReader.Result[Holiday] = Right(Holiday(\"last resort\", 7 days)) // Specifying both arguments ConfigSource.string(\"{ where: Texas, how-long: 3 hours }\").load[Holiday] // res5: ConfigReader.Result[Holiday] = Right(Holiday(\"Texas\", 3 hours)) A ProductHint can make the conversion fail if a key is missing from the config regardless of whether a default value exists or not: implicit val hint = ProductHint[Holiday](useDefaultArgs = false) ConfigSource.string(\"{ how-long: 21 days }\").load[Holiday] // res6: ConfigReader.Result[Holiday] = Left( // ConfigReaderFailures( // ConvertFailure(KeyNotFound(\"where\", Set()), Some(ConfigOrigin(String)), \"\"), // WrappedArray() // ) // ) Unknown keys By default, PureConfig ignores keys in the config that do not map to any case class field, leading to potential bugs due to misspellings: ConfigSource.string(\"{ wher: Texas, how-long: 21 days }\").load[Holiday] // res8: ConfigReader.Result[Holiday] = Right(Holiday(\"last resort\", 21 days)) With a ProductHint, one can tell the converter to fail if an unknown key is found: implicit val hint = ProductHint[Holiday](allowUnknownKeys = false) // hint: ProductHint[Holiday] = ProductHintImpl(&lt;function1&gt;, true, false) ConfigSource.string(\"{ wher: Texas, how-long: 21 days }\").load[Holiday] // res9: ConfigReader.Result[Holiday] = Left( // ConfigReaderFailures( // ConvertFailure(UnknownKey(\"wher\"), Some(ConfigOrigin(String)), \"wher\"), // List() // ) // ) Missing keys The default behavior of ConfigReaders that are derived in PureConfig is to return a KeyNotFound failure when a required key is missing unless its type is an Option, in which case it is read as a None. Consider this configuration: import pureconfig._ import pureconfig.generic.auto._ case class Foo(a: Int) case class FooOpt(a: Option[Int]) Loading a Foo results in a Left because of missing keys, but loading a FooOpt produces a Right: ConfigSource.empty.load[Foo] // res11: ConfigReader.Result[Foo] = Left( // ConfigReaderFailures( // ConvertFailure( // KeyNotFound(\"a\", Set()), // Some(ConfigOrigin(empty config)), // \"\" // ), // WrappedArray() // ) // ) ConfigSource.empty.load[FooOpt] // res12: ConfigReader.Result[FooOpt] = Right(FooOpt(None)) However, if you want to allow your custom ConfigReaders to handle missing keys, you can extend the ReadsMissingKeys trait. For ConfigReaders extending ReadsMissingKeys, a missing key will issue a call to the from method of the available ConfigReader for that type with a cursor to an undefined value. Under this setup: implicit val maybeIntReader = new ConfigReader[Int] with ReadsMissingKeys { override def from(cur: ConfigCursor) = if (cur.isUndefined) Right(42) else ConfigReader[Int].from(cur) } You can load an empty configuration and get a Right: ConfigSource.empty.load[Foo] // res13: ConfigReader.Result[Foo] = Right(Foo(42))"
    } ,    
    {
      "title": "Sealed Families",
      "url": "/v0.17.5/docs/overriding-behavior-for-sealed-families.html",
      "content": "Sealed Families In order for PureConfig to disambiguate between different options of a sealed family of case classes, it must read and write additional information in configurations. By default it uses the additional field type, encoding the concrete class represented in the configuration. Given an AnimalConf sealed trait: import pureconfig._ import pureconfig.generic.auto._ sealed trait AnimalConf case class DogConf(age: Int) extends AnimalConf case class BirdConf(canFly: Boolean) extends AnimalConf This will load a DogConf instance: ConfigSource.string(\"{ type: dog-conf, age: 4 }\").load[AnimalConf] // res0: ConfigReader.Result[AnimalConf] = Right(DogConf(4)) For sealed families, PureConfig provides a way to customize the conversion without replacing the default ConfigReader. By putting in scope an instance of CoproductHint for that sealed family, we can customize how the disambiguation is made. For example, if type clashes with one of the fields of a case class option, we can use another field. First, define a CoproductHint in implicit scope: import pureconfig.generic.FieldCoproductHint implicit val animalConfHint = new FieldCoproductHint[AnimalConf](\"kind\") Then load the config: ConfigSource.string(\"{ kind: dog-conf, age: 4 }\").load[AnimalConf] // res1: ConfigReader.Result[AnimalConf] = Right(DogConf(4)) FieldCoproductHint can also be adapted to write class names in a different way. First, define a new FieldCoproductHint in implicit scope: implicit val animalConfHint = new FieldCoproductHint[AnimalConf](\"type\") { override def fieldValue(name: String) = name.dropRight(\"Conf\".length) } Then load the config: ConfigSource.string(\"{ type: Bird, can-fly: true }\").load[AnimalConf] // res2: ConfigReader.Result[AnimalConf] = Right(BirdConf(true)) If you encode enumerations using sealed traits of case objects, you can use the deriveEnumerationReader method from the pureconfig.generic.semiauto package to derive ConfigReader instances for your sealed trait. import pureconfig._ import pureconfig.generic.auto._ import pureconfig.generic.semiauto._ sealed trait Season case object Spring extends Season case object Summer extends Season case object Autumn extends Season case object Winter extends Season implicit val seasonConvert: ConfigReader[Season] = deriveEnumerationReader[Season] case class MyConf(list: List[Season]) We can load seasons by specifying them by class name: ConfigSource.string(\"{ list: [spring, summer, autumn, winter] }\").load[MyConf] // res4: ConfigReader.Result[MyConf] = Right( // MyConf(List(Spring, Summer, Autumn, Winter)) // ) By default, enumerations will be encoded as strings with the kebab-case representation of the class name, but that behavior can be overridden by specifying a different transformation function. sealed trait Color case object RainyBlue extends Color case object SunnyYellow extends Color implicit val colorReader: ConfigReader[Color] = deriveEnumerationReader[Color](ConfigFieldMapping(PascalCase, SnakeCase)) case class ColorList(colors: List[Color]) ConfigSource.string(\"{ colors: [rainy_blue, sunny_yellow] }\").load[ColorList] // res5: ConfigReader.Result[ColorList] = Right( // ColorList(List(RainyBlue, SunnyYellow)) // )"
    } ,    
    {
      "title": "Overriding Behavior for Types",
      "url": "/v0.17.5/docs/overriding-behavior-for-types.html",
      "content": "Overriding Behavior for Types It is possible to override the behavior of PureConfig for a given type A just by putting another implicit instance of ConfigReader[A] in scope. This happens because the newly defined implicit value will have a higher priority than the ones defined by PureConfig, according to the Scala implicit precedence rules. For instance, the default behavior of PureConfig for String is to return the string itself in the configuration: import com.typesafe.config.ConfigValueFactory import pureconfig._ import pureconfig.generic.auto._ ConfigReader[String].from(ConfigValueFactory.fromAnyRef(\"FooBar\")) // res0: ConfigReader.Result[String] = Right(\"FooBar\") Now let’s say that we want to override this behavior such that Strings are always read lower case. We can define a custom ConfigReader instance for String: import pureconfig.ConvertHelpers._ implicit val overrideStrReader = ConfigReader.fromString[String](catchReadError(_.toLowerCase)) PureConfig will now use the custom overrideStrReader instance: ConfigReader[String].from(ConfigValueFactory.fromAnyRef(\"FooBar\")) // res1: ConfigReader.Result[String] = Right(\"foobar\") All the techniques described in Supporting New Types can be used to define the higher priority reader. PureConfig has more fine-grained ways to configure the default readers for case classes and sealed families. The Case Classes and Sealed Families subsections show how to do that."
    } ,      
    {
      "title": "Scala 3 Derivation",
      "url": "/v0.17.5/docs/scala-3-derivation.html",
      "content": "Scala 3 Derivation Scala 3 introduced native support for type class derivation - a way to automatically generate type class instances for enums, enum cases, case classes, case objects and sealed traits that only have the aforementioned types as children. Instances are generated on demand by adding a derives clause on data types. PureConfig has some limited support for derivation of ConfigReader instances. In order to enable it, the relevant extensions must be imported: import pureconfig._ import pureconfig.generic.derivation.default._ After that, you can derive ConfigReader instances for your config class using a derives clause: sealed trait AnimalConf derives ConfigReader case class DogConf(age: Int) extends AnimalConf case class BirdConf(canFly: Boolean) extends AnimalConf ConfigSource.string(\"{ type: dog-conf, age: 4 }\").load[AnimalConf] // val res0: pureconfig.ConfigReader.Result[AnimalConf] = Right(DogConf(4)) Readers for enumerations of objects can also be derived by using EnumConfigReader instead: import pureconfig.generic.derivation.EnumConfigReader enum Season derives EnumConfigReader { case Spring, Summer, Autumn, Winter } case class MyConf(list: List[Season]) derives ConfigReader ConfigSource.string(\"{ list: [spring, summer, autumn, winter] }\").load[MyConf] // val res1: pureconfig.ConfigReader.Result[MyConf] = Right(MyConf(List(Spring, Summer, Autumn, Winter))) Limitations There is currently no way to customize case class and sealed trait derivation - any ProductHint and CoproductHint instances in scope are ignored. ConfigWriter derivation is not supported at the moment. Overall, consider this to be in alpha/beta stage. This implementation is not as mature as the Shapeless or Magnolia-based derivation libraries available in Scala 2 yet so please report any bugs that you find!"
    } ,      
    {
      "title": "Supporting New Types",
      "url": "/v0.17.5/docs/supporting-new-types.html",
      "content": "{{page.title}} Not all types are supported automatically by PureConfig. For instance, classes that are not case classes are not supported out-of-the-box: import pureconfig._ import pureconfig.generic.auto._ class MyInt(value: Int) { override def toString: String = s\"MyInt($value)\" } case class Conf(n: MyInt) In order to read an instance of a given type A from a config, PureConfig needs to have in scope in implicit instance of ConfigReader[A]. This won’t compile because there’s no ConfigReader instance for MyInt: ConfigSource.string(\"{ n: 1 }\").load[Conf] // error: could not find implicit value for parameter reader: pureconfig.ConfigReader[repl.MdocSession.MdocApp.Conf] // ConfigSource.string(\"{ n: 1 }\").load[Conf] // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ PureConfig can be extended to support those types. To do so, an instance for the ConfigReader type class must be provided. There are three main ways to build such an instance: Modify an existing instance for another type by using one of the ConfigReader combinators; Use one of the ConfigReader convenience factory methods; Create a new implementation of the ConfigReader interface from scratch. For the MyInt type above, we could create a ConfigReader[MyInt] by mapping the result of ConfigReader[Int] like this: implicit val myIntReader = ConfigReader[Int].map(n =&gt; new MyInt(n)) Note that the ConfigReader[Int] expression “summons” an existing implicit instance, being syntactic sugar for implicitly[ConfigReader[Int]]. This is usually the easiest way to create a ConfigReader for simple types. See Combinators for more examples. As an example for the second approach, we could read the required integer by parsing it from a string form like this: implicit val myIntReader = ConfigReader.fromString[MyInt]( ConvertHelpers.catchReadError(s =&gt; new MyInt(s.toInt))) The fromString factory method allows users to easily read data from string representations in the config. catchReadError is a convenience function that catches exceptions thrown by the parsing code and transforms them into PureConfig errors. Finally, we could simply implement the ConfigReader interface by hand: implicit val myIntReader = new ConfigReader[MyInt] { def from(cur: ConfigCursor) = cur.asString.map(s =&gt; new MyInt(s.toInt)) } The interface consists of a single from method that takes a ConfigCursor and returns an Either of a MyInt or a list of errors. You can read more about cursors at Config Cursors. Using any of the approaches above would now make the config be loaded successfully: ConfigSource.string(\"{ n: 1 }\").load[Conf] // res1: ConfigReader.Result[Conf] = Right(Conf(MyInt(1))) The case above serves as an example for most simple types. While for those types it is straightforward to create a ConfigReader, complex types that require access to an entire sub-tree of the configuration to be read can make implementing an appropriate ConfigReader non-trivial. The Complex Types section presents different approaches for doing that, along with their advantages and disadvantages."
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
